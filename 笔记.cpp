const int a;//常整型
int const a;//同上
const int *a;//a为指向常整数的指针
int * const a;//a为常指针
const int * const a;//
int const * const a;//常整数，常指针
/*
short 占据的内存大小是2 个byte；
int占据的内存大小是4 个byte；
long占据的内存大小是4 个byte；
float占据的内存大小是4 个byte；
double占据的内存大小是8 个byte；
char占据的内存大小是1 个byte。
*/
结构体对其的原则
语法：#pragma pack( [show] | [push | pop] [, identifier], n )
作用：指定结构，联合和类的包对齐方式（pack alignment）
1.结构体内成员按自身按自身长度自对齐。
自身长度，如char=1，short=2，int=4，double=8,。所谓自对齐，指的是该成员的起始位置的内存地址必须是它自身长度的整数倍。如int只能以0,4,8这类的地址开始
2.结构体的总大小为结构体的有效对齐值的整数倍
#pragma pack(2)
struct AA{
    char a;
    int b;
    char c; 
}aa
sizeof（aa）=10,
为什么呢？a到c只占9字节长度，因为结构体的有效对齐长度在pack指定的2和int的4中取
较小的值2。故取2的倍数10。
如果当pack指定为8呢?那就仍然按4来对齐，结果仍然是12。
大端模式（BE big-endian）是指数据的低位保存在内存的高地址中，而数据的高位，保存在内存的低地址中（低对高，高对高）
小端模式（LE little-endian），是指数据的低位保存在内存的低地址中，而数据的高位保存在内存的高地址中（低对低，高对高）
大端（低地址-高地址）小段（高地址-低地址）
2、简述static关键字对于工程模块化的作用。
解答：在C语言中，static有下3个作用：
函数体内的static变量的作用范围为该函数体，不同于auto变量，该变量的内存只被分配一次，以为其值在下次调用时仍维持上次的值（该变量存放在静态变量区）；
	在模块内static全局变量可以被模块内所有函数访问，但不能被模块外其他函数访问。（注意，只有在定义了变量后才能使用。如果变量定义在使用之后，要用extern 声明。所以，一般全部变量都会在文件的最开始处定义。）；
	在模块内的static函数只可被这一模块内的其他函数调用，这个函数的使用范围被限制在声明它的模块内。
在嵌入式系统中，要时刻懂得移植的重要性，程序可能是很多程序员共同协作同时完成，在定义变量及函数的过程，可能会重名，这给系统的集成带来麻烦，因此保证不冲突的办法是显示的表示此变量或者函数是本地的，static即可。在Linux的模块编程中，这一条很明显，所有的函数和全局变量都要用static关键字声明，将其作用域限制在本模块内部，与其他模块共享的函数或者变量要EXPORT到内核中。
#define S_Y (60*60*24*365)UL
#define MIN(A,B) ((A)<(B)? (A):(B))
typeof(*x) y;
把y定义成x指向数据类型的数组：
#define min(x,y) ({const typeof(x) _x=(x);const typeof(y) _y=(y);(void) (&_x==&_y);_x<_y? _x:_y;})
关心返回值的话外面必须加括号，用这种方式可以可以防止i++类型的参数被重复计算。
内核使用printk()打印！
应用层使用printf()打印！
printk()和printf()之间的一个显著区别在于printk()允许通过指定一个标志来设置优先级。
在<linux/kernel.h>头文件里一共定义了8个级别（0-7）的输出，从高到低分别由如下常量表示：
KERN_EMERG         ：    最高级别，一般只用来打印崩溃信息
KERN_ALERT         ：    需要立即处理的信息
KERN_CRIT          ：    关键信息，一般用来显示严重的硬件和软件错误
KERN_ERR           ：    用来显示硬件错误
KERN_WARNING       ：    显示不会造成严重错误的警告信息
KERN_NOTICE        ：    显示需要引起注意的信息
KERN_INFO          ：　　显示一般信息，例如驱动所发现的硬件列表
KERN_DEBUＧ　　　　：　　用来显示调试信息

void example()
{
	printf("本函数名：%s\n", __func__);
}
void *memcpy(void *str1, const void *str2, size_t n)
str1 -- 指向用于存储复制内容的目标数组，类型强制转换为 void* 指针。
str2 -- 指向要复制的数据源，类型强制转换为 void* 指针。
n -- 要被复制的字节数(char 1,int 4)
switch 不加break则一直循环
#define CALC(x,y) x*y+x
int main()//没有加括号，所以结果为26
{
	int a = CALC(2 * 3, 3 + 2);
	printf("result= %d\n", a);
	return 0;
}
void swap(int *a, int *b) 
{//只交换形式参数，所以无效
	int *t;
	t = a;
	a = b;
	b = t;
}
void swap(int *a,int *b)
{//指针法
	int *t；
	t=*a;
	*a=*b;
	*b=t;
}
void swap(int &a,int &b)
{//引用法，不是取地址
	int temp=a;
	a=b;
	b=temp;
}
int a=1;
int &b=a;
int *p=&a;
p=&a=&b;
int &k = *p;//这里的*也是解引用的意思
cout<<k<<endl;//这样也是可以的
x |= (1<<y) //将X的第Y位置1
x &= ~(1<<y) //将X的第Y位清0
0 != x & (1<<y) // 判断x的y位的 是否为 1
(0 == x & (1<<y)) // 判断x的y位的 是否为 0
队列空间缓冲由进程申请，栈的空间缓冲由OS分配
上半部是不能中断的，仅仅是响应中断；下半部是可以中断的。对于适时要求高的，必须放在上半部。下半部的实现主要是通过软中断、tasklet、工作队列来实现的。
上半部的功能是响应中断。当中断发生时，它就把设备驱动程序中中断处理例程的下半部挂到设备的下半部执行队列中去，
然后继续等待新的中断到来。这样一来，上半部的执行速度就会很快，它就可以接受更多它负责的设备所产生的中断了。
下半部机制
Linux内核的五大模块：进程调度模块、内存管理模块、文件系统模块、进程间通信模块、网络接口模块。
进程调度模块：用来负责控制进程对CPU 资源的使用。所采取的调度策略是各进程能够公平合理地访问CPU，同时保证内核能及时地执行硬件操作；
内存管理模块：用于确保所有进程能够安全地共享机器主内存区，同时，内存管理模块还支持虚拟内存管理方式，使得Linux 支持进程使用比实际内存空间更多的内存容量。并可以利用文件系统，对暂时不用的内存数据块交换到外部存储设备上去，当需要时再交换回来；
文件系统模块：用于支持对外部设备的驱动和存储。虚拟文件系统模块通过向所有的外部存储设备提供一个通用的文件接口，隐藏了各种硬件设备的不同细节。从而提供并支持与其它操作系统兼容的多种文件系统格式；
进程间通信模块：用于支持多种进程间的信息交换方式；
网络接口模块：提供对多种网络通信标准的访问并支持许多网络硬件。

如果将内核比作一座工厂，那么Linux中众多的接口就是通往这个巨大工厂的高速公路。
这条路要足够坚固，禁得起各种破坏(Robust)。要能跑得了运货的卡车，还要能升降飞机。
(Compatible)。当然了这条路要越宽越好（Performant）。如下图所标，Linux中有四种类型的接口。
位于内核和用户之间的API(应用程序接口)和ABI（应用二进制接口）。内核内部的API和ABI。下面我们逐条的来看看这些接口。

			
